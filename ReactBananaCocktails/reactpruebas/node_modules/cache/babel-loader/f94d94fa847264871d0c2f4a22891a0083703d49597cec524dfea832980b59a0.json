{"ast":null,"code":"import { createContext, useRef, useState, useLayoutEffect, createElement, useContext, useEffect, useMemo, useCallback, Children, isValidElement, Fragment } from 'react';\nimport { createMemoryHistory, Action, parsePath } from 'history';\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar readOnly = process.env.NODE_ENV !== \"production\" ? function (obj) {\n  return Object.freeze(obj);\n} : function (obj) {\n  return obj;\n};\nfunction invariant(cond, message) {\n  if (!cond) throw new Error(message);\n}\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message); // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\nvar alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    process.env.NODE_ENV !== \"production\" ? warning(false, message) : void 0;\n  }\n}\nvar NavigatorContext = /*#__PURE__*/createContext(null);\nvar LocationContext = /*#__PURE__*/createContext({\n  static: false\n});\nif (process.env.NODE_ENV !== \"production\") {\n  LocationContext.displayName = \"Location\";\n}\nvar RouteContext = /*#__PURE__*/createContext({\n  outlet: null,\n  params: readOnly({}),\n  pathname: \"\",\n  basename: \"\",\n  route: null\n});\nif (process.env.NODE_ENV !== \"production\") {\n  RouteContext.displayName = \"Route\";\n}\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/api/MemoryRouter\n */\n\nfunction MemoryRouter(_ref) {\n  var children = _ref.children,\n    initialEntries = _ref.initialEntries,\n    initialIndex = _ref.initialIndex;\n  var historyRef = useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries: initialEntries,\n      initialIndex: initialIndex\n    });\n  }\n  var history = historyRef.current;\n  var _React$useState = useState({\n      action: history.action,\n      location: history.location\n    }),\n    state = _React$useState[0],\n    setState = _React$useState[1];\n  useLayoutEffect(function () {\n    return history.listen(setState);\n  }, [history]);\n  return /*#__PURE__*/createElement(Router, {\n    children: children,\n    action: state.action,\n    location: state.location,\n    navigator: history\n  });\n}\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/api/Navigate\n */\n\nfunction Navigate(_ref2) {\n  var to = _ref2.to,\n    replace = _ref2.replace,\n    state = _ref2.state;\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false,\n  // TODO: This error is probably because they somehow have 2 versions of\n  // the router loaded. We can help them understand how to avoid that.\n  \"<Navigate> may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  process.env.NODE_ENV !== \"production\" ? warning(!useContext(LocationContext).static, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : void 0;\n  var navigate = useNavigate();\n  useEffect(function () {\n    navigate(to, {\n      replace: replace,\n      state: state\n    });\n  });\n  return null;\n}\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/api/Outlet\n */\n\nfunction Outlet(_props) {\n  return useOutlet();\n}\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/api/Route\n */\n\nfunction Route(_ref3) {\n  var _ref3$element = _ref3.element,\n    element = _ref3$element === void 0 ? /*#__PURE__*/createElement(Outlet, null) : _ref3$element;\n  return element;\n}\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/api/Router\n */\n\nfunction Router(_ref4) {\n  var _ref4$children = _ref4.children,\n    children = _ref4$children === void 0 ? null : _ref4$children,\n    _ref4$action = _ref4.action,\n    action = _ref4$action === void 0 ? Action.Pop : _ref4$action,\n    location = _ref4.location,\n    navigator = _ref4.navigator,\n    _ref4$static = _ref4.static,\n    staticProp = _ref4$static === void 0 ? false : _ref4$static;\n  !!useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"You cannot render a <Router> inside another <Router>.\" + \" You never need more than one.\") : invariant(false) : void 0;\n  return /*#__PURE__*/createElement(NavigatorContext.Provider, {\n    value: navigator\n  }, /*#__PURE__*/createElement(LocationContext.Provider, {\n    children: children,\n    value: {\n      action: action,\n      location: location,\n      static: staticProp\n    }\n  }));\n}\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/api/Routes\n */\n\nfunction Routes(_ref5) {\n  var _ref5$basename = _ref5.basename,\n    basename = _ref5$basename === void 0 ? \"\" : _ref5$basename,\n    children = _ref5.children,\n    location = _ref5.location;\n  var routes = createRoutesFromChildren(children);\n  return useRoutes_(routes, location, basename);\n} ///////////////////////////////////////////////////////////////////////////////\n// HOOKS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Blocks all navigation attempts. This is useful for preventing the page from\n * changing until some condition is met, like saving form data.\n *\n * @see https://reactrouter.com/api/useBlocker\n */\n\nfunction useBlocker(blocker, when) {\n  if (when === void 0) {\n    when = true;\n  }\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false,\n  // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useBlocker() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  var navigator = useContext(NavigatorContext);\n  useEffect(function () {\n    if (!when) return;\n    var unblock = navigator.block(function (tx) {\n      var autoUnblockingTx = _extends({}, tx, {\n        retry: function retry() {\n          // Automatically unblock the transition so it can play all the way\n          // through before retrying it. TODO: Figure out how to re-enable\n          // this block if the transition is cancelled for some reason.\n          unblock();\n          tx.retry();\n        }\n      });\n      blocker(autoUnblockingTx);\n    });\n    return unblock;\n  }, [navigator, blocker, when]);\n}\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/api/useHref\n */\n\nfunction useHref(to) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false,\n  // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useHref() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  var navigator = useContext(NavigatorContext);\n  var path = useResolvedPath(to);\n  return navigator.createHref(path);\n}\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/api/useInRouterContext\n */\n\nfunction useInRouterContext() {\n  return useContext(LocationContext).location != null;\n}\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/api/useLocation\n */\n\nfunction useLocation() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false,\n  // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useLocation() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  return useContext(LocationContext).location;\n}\n/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/api/useMatch\n */\n\nfunction useMatch(pattern) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false,\n  // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useMatch() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  var location = useLocation();\n  return matchPath(pattern, location.pathname);\n}\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/api/useNavigate\n */\n\nfunction useNavigate() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false,\n  // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useNavigate() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  var navigator = useContext(NavigatorContext);\n  var _React$useContext = useContext(RouteContext),\n    basename = _React$useContext.basename;\n  var _useLocation = useLocation(),\n    pathname = _useLocation.pathname;\n  var activeRef = useRef(false);\n  useEffect(function () {\n    activeRef.current = true;\n  });\n  var navigate = useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (activeRef.current) {\n      if (typeof to === \"number\") {\n        navigator.go(to);\n      } else {\n        var path = resolvePath(to, pathname, basename);\n        (!!options.replace ? navigator.replace : navigator.push)(path, options.state);\n      }\n    } else {\n      process.env.NODE_ENV !== \"production\" ? warning(false, \"You should call navigate() in a useEffect, not when \" + \"your component is first rendered.\") : void 0;\n    }\n  }, [basename, navigator, pathname]);\n  return navigate;\n}\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/api/useOutlet\n */\n\nfunction useOutlet() {\n  return useContext(RouteContext).outlet;\n}\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/api/useParams\n */\n\nfunction useParams() {\n  return useContext(RouteContext).params;\n}\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/api/useResolvedPath\n */\n\nfunction useResolvedPath(to) {\n  var _React$useContext2 = useContext(RouteContext),\n    pathname = _React$useContext2.pathname,\n    basename = _React$useContext2.basename;\n  return useMemo(function () {\n    return resolvePath(to, pathname, basename);\n  }, [to, pathname, basename]);\n}\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/api/useRoutes\n */\n\nfunction useRoutes(partialRoutes, _temp) {\n  var _ref6 = _temp === void 0 ? {} : _temp,\n    _ref6$basename = _ref6.basename,\n    basename = _ref6$basename === void 0 ? \"\" : _ref6$basename,\n    location = _ref6.location;\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false,\n  // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useRoutes() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  var routes = useMemo(function () {\n    return createRoutesFromArray(partialRoutes);\n  }, [partialRoutes]);\n  return useRoutes_(routes, location, basename);\n}\nfunction useRoutes_(routes, locationOverride, basename) {\n  if (basename === void 0) {\n    basename = \"\";\n  }\n  var _React$useContext3 = useContext(RouteContext),\n    parentRoute = _React$useContext3.route,\n    parentPathname = _React$useContext3.pathname,\n    parentParams = _React$useContext3.params;\n  if (process.env.NODE_ENV !== \"production\") {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    var parentPath = parentRoute && parentRoute.path;\n    warningOnce(parentPathname, !parentRoute || parentRoute.path.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + parentPath + \"/*\\\">.\"));\n  }\n  var basenameForMatching = basename ? joinPaths([parentPathname, basename]) : parentPathname;\n  var contextLocation = useLocation();\n  var location = locationOverride !== null && locationOverride !== void 0 ? locationOverride : contextLocation;\n  var matches = useMemo(function () {\n    return matchRoutes(routes, location, basenameForMatching);\n  }, [location, routes, basenameForMatching]);\n  if (!matches) {\n    // TODO: Warn about nothing matching, suggest using a catch-all route.\n    return null;\n  } // Otherwise render an element.\n\n  var allParams = {};\n  var element = matches.reduceRight(function (outlet, _ref7) {\n    var params = _ref7.params,\n      pathname = _ref7.pathname,\n      route = _ref7.route;\n    allParams = _extends({}, allParams, params);\n    return /*#__PURE__*/createElement(RouteContext.Provider, {\n      children: route.element,\n      value: {\n        outlet: outlet,\n        params: readOnly(_extends({}, parentParams, allParams)),\n        pathname: joinPaths([basenameForMatching, pathname]),\n        basename: basename,\n        route: route\n      }\n    });\n  }, null);\n  return element;\n} ///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from an array of JavaScript objects. Used internally\n * by `useRoutes` to normalize the route config.\n *\n * @see https://reactrouter.com/api/createRoutesFromArray\n */\n\nfunction createRoutesFromArray(array) {\n  return array.map(function (partialRoute) {\n    var route = {\n      path: partialRoute.path || \"/\",\n      caseSensitive: partialRoute.caseSensitive === true,\n      element: partialRoute.element || /*#__PURE__*/createElement(Outlet, null)\n    };\n    if (partialRoute.children) {\n      route.children = createRoutesFromArray(partialRoute.children);\n    }\n    return route;\n  });\n}\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/api/createRoutesFromChildren\n */\n\nfunction createRoutesFromChildren(children) {\n  var routes = [];\n  Children.forEach(children, function (element) {\n    if (! /*#__PURE__*/isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n    if (element.type === Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children));\n      return;\n    }\n    var route = {\n      path: element.props.path || \"/\",\n      caseSensitive: element.props.caseSensitive === true,\n      // Default behavior is to just render the element that was given. This\n      // permits people to use any element they prefer, not just <Route> (though\n      // all our official examples and docs use <Route> for clarity).\n      element: element\n    };\n    if (element.props.children) {\n      var childRoutes = createRoutesFromChildren(element.props.children);\n      if (childRoutes.length) {\n        route.children = childRoutes;\n      }\n    }\n    routes.push(route);\n  });\n  return routes;\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/api/generatePath\n */\n\nfunction generatePath(path, params) {\n  if (params === void 0) {\n    params = {};\n  }\n  return path.replace(/:(\\w+)/g, function (_, key) {\n    !(params[key] != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Missing \\\":\" + key + \"\\\" param\") : invariant(false) : void 0;\n    return params[key];\n  }).replace(/\\/*\\*$/, function (_) {\n    return params[\"*\"] == null ? \"\" : params[\"*\"].replace(/^\\/*/, \"/\");\n  });\n}\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/api/matchRoutes\n */\n\nfunction matchRoutes(routes, location, basename) {\n  if (basename === void 0) {\n    basename = \"\";\n  }\n  if (typeof location === \"string\") {\n    location = parsePath(location);\n  }\n  var pathname = location.pathname || \"/\";\n  if (basename) {\n    var base = basename // // Basename should be case-insensitive\n    // https://github.com/remix-run/react-router/issues/7997#issuecomment-911916907\n    .toLowerCase().replace(/^\\/*/, \"/\").replace(/\\/+$/, \"\");\n    if (pathname.toLowerCase().startsWith(base)) {\n      pathname = pathname.slice(base.length) || \"/\";\n    } else {\n      // Pathname does not start with the basename, no match.\n      return null;\n    }\n  }\n  var branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  var matches = null;\n  for (var i = 0; matches == null && i < branches.length; ++i) {\n    // TODO: Match on search, state too?\n    matches = matchRouteBranch(branches[i], pathname);\n  }\n  return matches;\n}\nfunction flattenRoutes(routes, branches, parentPath, parentRoutes, parentIndexes) {\n  if (branches === void 0) {\n    branches = [];\n  }\n  if (parentPath === void 0) {\n    parentPath = \"\";\n  }\n  if (parentRoutes === void 0) {\n    parentRoutes = [];\n  }\n  if (parentIndexes === void 0) {\n    parentIndexes = [];\n  }\n  routes.forEach(function (route, index) {\n    route = _extends({}, route, {\n      path: route.path || \"/\",\n      caseSensitive: !!route.caseSensitive,\n      element: route.element\n    });\n    var path = joinPaths([parentPath, route.path]);\n    var routes = parentRoutes.concat(route);\n    var indexes = parentIndexes.concat(index); // Add the children before adding this route to the array so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n\n    if (route.children) {\n      flattenRoutes(route.children, branches, path, routes, indexes);\n    }\n    branches.push([path, routes, indexes]);\n  });\n  return branches;\n}\nfunction rankRouteBranches(branches) {\n  var pathScores = branches.reduce(function (memo, _ref8) {\n    var path = _ref8[0];\n    memo[path] = computeScore(path);\n    return memo;\n  }, {}); // Sorting is stable in modern browsers, but we still support IE 11, so we\n  // need this little helper.\n\n  stableSort(branches, function (a, b) {\n    var aPath = a[0],\n      aIndexes = a[2];\n    var aScore = pathScores[aPath];\n    var bPath = b[0],\n      bIndexes = b[2];\n    var bScore = pathScores[bPath];\n    return aScore !== bScore ? bScore - aScore // Higher score first\n    : compareIndexes(aIndexes, bIndexes);\n  });\n}\nvar paramRe = /^:\\w+$/;\nvar dynamicSegmentValue = 2;\nvar emptySegmentValue = 1;\nvar staticSegmentValue = 10;\nvar splatPenalty = -2;\nvar isSplat = function isSplat(s) {\n  return s === \"*\";\n};\nfunction computeScore(path) {\n  var segments = path.split(\"/\");\n  var initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n  return segments.filter(function (s) {\n    return !isSplat(s);\n  }).reduce(function (score, segment) {\n    return score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue);\n  }, initialScore);\n}\nfunction compareIndexes(a, b) {\n  var siblings = a.length === b.length && a.slice(0, -1).every(function (n, i) {\n    return n === b[i];\n  });\n  return siblings ?\n  // If two routes are siblings, we should try to match the earlier sibling\n  // first. This allows people to have fine-grained control over the matching\n  // behavior by simply putting routes with identical paths in the order they\n  // want them tried.\n  a[a.length - 1] - b[b.length - 1] :\n  // Otherwise, it doesn't really make sense to rank non-siblings by index,\n  // so they sort equally.\n  0;\n}\nfunction stableSort(array, compareItems) {\n  // This copy lets us get the original index of an item so we can preserve the\n  // original ordering in the case that they sort equally.\n  var copy = array.slice(0);\n  array.sort(function (a, b) {\n    return compareItems(a, b) || copy.indexOf(a) - copy.indexOf(b);\n  });\n}\nfunction matchRouteBranch(branch, pathname) {\n  var routes = branch[1];\n  var matchedPathname = \"/\";\n  var matchedParams = {};\n  var matches = [];\n  for (var i = 0; i < routes.length; ++i) {\n    var route = routes[i];\n    var remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n    var routeMatch = matchPath({\n      path: route.path,\n      caseSensitive: route.caseSensitive,\n      end: i === routes.length - 1\n    }, remainingPathname);\n    if (!routeMatch) return null;\n    matchedPathname = joinPaths([matchedPathname, routeMatch.pathname]);\n    matchedParams = _extends({}, matchedParams, routeMatch.params);\n    matches.push({\n      route: route,\n      pathname: matchedPathname,\n      params: readOnly(matchedParams)\n    });\n  }\n  return matches;\n}\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/api/matchPath\n */\n\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === \"string\") {\n    pattern = {\n      path: pattern\n    };\n  }\n  var _pattern = pattern,\n    path = _pattern.path,\n    _pattern$caseSensitiv = _pattern.caseSensitive,\n    caseSensitive = _pattern$caseSensitiv === void 0 ? false : _pattern$caseSensitiv,\n    _pattern$end = _pattern.end,\n    end = _pattern$end === void 0 ? true : _pattern$end;\n  var _compilePath = compilePath(path, caseSensitive, end),\n    matcher = _compilePath[0],\n    paramNames = _compilePath[1];\n  var match = pathname.match(matcher);\n  if (!match) return null;\n  var matchedPathname = match[1];\n  var values = match.slice(2);\n  var params = paramNames.reduce(function (memo, paramName, index) {\n    memo[paramName] = safelyDecodeURIComponent(values[index] || \"\", paramName);\n    return memo;\n  }, {});\n  return {\n    path: path,\n    pathname: matchedPathname,\n    params: params\n  };\n}\nfunction compilePath(path, caseSensitive, end) {\n  var keys = [];\n  var source = \"^(\" + path.replace(/^\\/*/, \"/\") // Make sure it has a leading /\n  .replace(/\\/?\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n  .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n  .replace(/:(\\w+)/g, function (_, key) {\n    keys.push(key);\n    return \"([^\\\\/]+)\";\n  }) + \")\";\n  if (path.endsWith(\"*\")) {\n    if (path.endsWith(\"/*\")) {\n      source += \"(?:\\\\/(.+)|\\\\/?)\"; // Don't include the / in params['*']\n    } else {\n      source += \"(.*)\";\n    }\n    keys.push(\"*\");\n  } else if (end) {\n    source += \"\\\\/?\";\n  }\n  if (end) source += \"$\";\n  var flags = caseSensitive ? undefined : \"i\";\n  var matcher = new RegExp(source, flags);\n  return [matcher, keys];\n}\nfunction safelyDecodeURIComponent(value, paramName) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    process.env.NODE_ENV !== \"production\" ? warning(false, \"The value for the URL param \\\"\" + paramName + \"\\\" will not be decoded because\" + (\" the string \\\"\" + value + \"\\\" is a malformed URL segment. This is probably\") + (\" due to a bad percent encoding (\" + error + \").\")) : void 0;\n    return value;\n  }\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/api/resolvePath\n */\n\nfunction resolvePath(to, fromPathname, basename) {\n  if (fromPathname === void 0) {\n    fromPathname = \"/\";\n  }\n  if (basename === void 0) {\n    basename = \"\";\n  }\n  var _ref9 = typeof to === \"string\" ? parsePath(to) : to,\n    toPathname = _ref9.pathname,\n    _ref9$search = _ref9.search,\n    search = _ref9$search === void 0 ? \"\" : _ref9$search,\n    _ref9$hash = _ref9.hash,\n    hash = _ref9$hash === void 0 ? \"\" : _ref9$hash;\n  var pathname = toPathname ? resolvePathname(toPathname, toPathname.startsWith(\"/\") ? basename ? normalizeSlashes(\"/\" + basename) : \"/\" : fromPathname) : fromPathname;\n  return {\n    pathname: pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\nvar trimTrailingSlashes = function trimTrailingSlashes(path) {\n  return path.replace(/\\/+$/, \"\");\n};\nvar normalizeSlashes = function normalizeSlashes(path) {\n  return path.replace(/\\/\\/+/g, \"/\");\n};\nvar joinPaths = function joinPaths(paths) {\n  return normalizeSlashes(paths.join(\"/\"));\n};\nvar splitPath = function splitPath(path) {\n  return normalizeSlashes(path).split(\"/\");\n};\nvar normalizeSearch = function normalizeSearch(search) {\n  return !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\n};\nvar normalizeHash = function normalizeHash(hash) {\n  return !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n};\nfunction resolvePathname(toPathname, fromPathname) {\n  var segments = splitPath(trimTrailingSlashes(fromPathname));\n  var relativeSegments = splitPath(toPathname);\n  relativeSegments.forEach(function (segment) {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? joinPaths(segments) : \"/\";\n} ///////////////////////////////////////////////////////////////////////////////\n\nexport { MemoryRouter, Navigate, Outlet, Route, Router, Routes, LocationContext as UNSAFE_LocationContext, NavigatorContext as UNSAFE_NavigatorContext, RouteContext as UNSAFE_RouteContext, createRoutesFromArray, createRoutesFromChildren, generatePath, matchPath, matchRoutes, resolvePath, useBlocker, useHref, useInRouterContext, useLocation, useMatch, useNavigate, useOutlet, useParams, useResolvedPath, useRoutes };","map":{"version":3,"names":["warning","cond","message","Error","warningOnce","key","alreadyWarned","process","env","NODE_ENV","createContext","readOnly","MemoryRouter","_ref","location","history","Navigate","_ref2","navigate","to","staticProp","_ref4$static","useInRouterContext","invariant","value","navigator","unblock","block","tx","retry","useResolvedPath","createHref","path","useLocation","basename","_React$useContext","pathname","_useLocation","current","useCallback","options","useContext","RouteContext","outlet","useRoutes_","routes","locationOverride","route","parentPathname","_React$useContext3","parentParams","params","parentRoute","basenameForMatching","allParams","_extends","createElement","Provider","joinPaths","partialRoute","element","Outlet","children","createRoutesFromArray","isValidElement","Fragment","push","apply","createRoutesFromChildren","props"],"sources":["../../packages/react-router/index.tsx"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;SAmCKA,QAAAC,IAAA,EAAAC,OAAA;;;;;;;;;;MA8BC,UAAAC,KAAA,CAAgBD,OAAA,CAAhB;;EAIH;;;AAYH,SAAAE,YAAqBC,GAArB,EAAAJ,IAAA,EAAAC,OAAA;gBACcI,aAAA,CAAAD,GAAA;IACZC,aAAA,CAAAD,GAAA;IACAE,OAAA,CAAAC,GAAA,CAAAC,QAAA,oBAAAT,OAAA,CAAQ,OAAAE,OAAA,CAAR;;;oCAgDqBQ,aAAA,CAA+B,IAA/B;;;;AA2BvB,IAAAH,OAAA,CAAAC,GAAA,CAAAC,QAAA;gCAEsB;;;;QAShB,EAAAE,QAAA;;;SAKC;;;;;;;;;AAoDJ;;AACG,SAAUC,YAAVA,CAAAC,IAAA;;;;;;;;;;;;;;MA6CJC,QAAA,EAAUC,OAAA,CAAAD;;;;;;;;;;;;;;;;;;;;;;;;SAoCJE,SAAAC,KAAA;;;;;;;;;;;IAqBJC,QAAA,CAAAC,EAAA;;;MAAA;;;AAOH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAmFOC,UAAA,GAAAC,YAAA,cAAa,QAAAA,YAAA;GAInB,CAAAC,kBAAmB,KAAAf,OAAA,CAAAC,GAAA,CAAAC,QAAA,oBAAAc,SAAA,sGAAAA,SAAA;;IAQIC,KAAA,EAAAC;;;;;;YAEU,EAAEL;;;;AA0BrC;;;;;;;;;;;;;;;;AAmBA;;;;;;;;;;;;;;;;;;;;IA8CE,IAAIM,OACG,GAAAD,SAAA,CAAaE,KAAA,WAAAC,EAAA;;QAOlBC,KAAA,WAAAA,MAAA;;;;;YAQI,CAAAA,KAAA;;;;IAML,EAtBD;;;;;;;;;;;;qBA4CgB,KAAAtB,OAAA,CAAAC,GAAA,CAAAC,QAAA,oBAAAc,SAAA;EAAA;;;;aAUTO,eAAA,CAAAX,EAAA;kBAKO,CAACY,UAAA,CAAAC,IAAA;AAChB;AAGD;;;;;;;;;;;;;;;;;;;;AAwBI,SAAAC,YAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA+GEC,QAAA,GAAAC,iBAAA,CAAAD,QAAA;;IACAE,QAAA,GAAAC,YAAA,CAAAD,QAAA;;;aAIC,CAAAE,OAAA,GAAW;;iBAIaC,WAAA,WAAApB,EAAA,EAAAqB,OAAA;;;;;;;;;;MAYxB;;MAEHjC,OAAA,CAAAC,GAAA,CAAAC,QAAA,oBAAAT,OAAO,qGAAP;;GAd2B,GAAAkC,QAAA,EAmCtBT,SAAA,EAAAW,QAAA,CAnCsB;;;;;;;;;;qBAiDZ;SACdK,UAAA,CAAAC,YAAA,EAAAC,MAAA;;;;;;;;;;;;;;;;;;;sCA2BqCD,YAAA;;;;;;;AAQ1C;;;;;;;;;;;;;;GA4BEpB,kBAAA,KAAAf,OAAA,CAAAC,GAAA,CAAAC,QAAA,oBAAAc,SAAA;EAAA;;;;;;;;SAeKqB,WAAAC,MAAA,EAAAC,gBAAA,EAAAZ,QAAA;;;;;qCAWLa,KAAA;IACUC,cAAA,GAAAC,kBAAA,CAAVb,QAAA;IACMc,YAAA,GAAAD,kBAAA,CAAAE,MAAA;;;;;kBASM,GAAAC,WAAA,IAAkBA,WAAA,CAAApB,IAAA;;;;;;;;MAgC7BlB,QAAA,EAAA+B,MAAA,EAAAQ,mBAAA;gBAIW;IAEZ;;;;kBAKoB;;;;;IAEpBC,SAAA,GAAAC,QAAA,KAAAD,SAAA,EAAAH,MAAA;IAEA,oBAAAK,aAAA,CAAAd,YAAA,CAAAe,QAAA;;MAcIjC,KAAA,EAAiB;sBAAA;+DAAA;kBAITkC,SAAS,EAAAL,mBAAA,EAAAjB,QAAA,EAJA;0BAAA;;MAAA;MAdrB;;;;;;;;;;;;;;sCAwCyB;mBAGV,UAAAuB,YAAA;;iCAGgB;;eAEtBA,YAAA,CAAAC,OAAA,iBAAwBJ,aAAA,CAACK,MAAD;;QAE/BF,YAAA,CACOG,QAAA;YAEHA,QAAA,GAAAC,qBAAA,CAAAJ,YAAA,CAAAG,QAAA;;;;;;;;;;;;;;YA2BE;;QAKN,eAAAE,cAAA,CAAAJ,OAAA;;;MAGA;;yBAIqBK,QAAA;MACnB;MACApB,MAAA,CAAAqB,IAAA,CAAYC,KAAZ,CAAAtB,MAAA,EAGEuB,wBAAA,CAAAR,OAAA,CAAAS,KAAA,CAAAP,QAAA,CAHF;;;;mBAWW,CAAAO,KAAA,CAAArC,IAAA;;;;;;;gCAOa;qBACf,GAAAoC,wBAAA,CAAAR,OAAA,CAAAS,KAAA,CAAAP,QAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}